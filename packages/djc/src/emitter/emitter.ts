import path from 'path'

import debug from 'debug'
import fsx from 'fs-extra'
import Deps from '../dlang/deps'
import { fmt } from './fmt'

const log = debug(`dubbo:dj:emitterï¼šsay ~`)
const relWhiteList = ['js-to-java', '@dubbo/sugar']

const fileType = {
  ts: 'ts',
  go: 'go',
  java: 'java',
}

export default abstract class Emitter {
  curFilePath: string

  constructor(
    public fullClsName: string,
    lang: 'ts' | 'go' | 'java',
    baseDir: string
  ) {
    this.curFilePath = `${baseDir}/${lang}/${this.cls2Path(fullClsName)}.${
      fileType[lang]
    }`
  }

  imports(deps: Deps) {
    const imports = []
    for (let [fullClassName, { defaultImport, specifiers }] of Object.entries(
      deps.imports
    )) {
      if (relWhiteList.includes(fullClassName)) {
        imports.push(`import ${defaultImport} from '${fullClassName}'`)
      } else {
        let rel = this.relPath(this.fullClsName, fullClassName)
        if (!rel.startsWith('./') && !rel.startsWith('../')) {
          rel = './' + rel
        }

        let importName = ''
        if (defaultImport !== '') {
          importName += defaultImport + ''
        }
        if (specifiers.length > 0) {
          if (importName) {
            importName += ','
          }
          importName += `{${specifiers.join()}}`
        }
        imports.push(`import ${importName} from '${rel}'`)
      }
    }
    return imports
  }

  get mott() {
    return `
      /**
       * auto generated by dubbo dj
       * ~~~ ðŸ’— machine coding ðŸ’— ~~~
       */
    `
  }

  cls2Path(cls: string) {
    return cls.replace(/\./g, '/')
  }

  relPath(from: string, to: string) {
    const fromArr = from.split('.')
    fromArr.pop()
    // è®¡ç®—ç›¸å¯¹è·¯å¾„
    const relPath = path.relative(fromArr.join('/'), this.cls2Path(to))
    log(`${from} => relative => ${to} =>`, relPath)
    return relPath
  }

  // write to => ./dubbo/ts/**/*.ts
  async writeCode(): Promise<void> {
    try {
      await fsx.ensureFile(this.curFilePath)
      await fsx.writeFile(this.curFilePath, this.prettyCode)
      return log(
        `create ${this.fullClsName} => ${this.curFilePath} was successfully`
      )
    } catch (err) {
      log(`generate => '${this.fullClsName}' was failed, err:` + err)
      console.error(err)
    }
  }

  get prettyCode(): string {
    return fmt(this.code)
  }

  abstract get code(): string
}
